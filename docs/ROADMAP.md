# Agent Coordinator â€” Unified Project Roadmap

## Vision

A unified multi-agent coordination system for Antigravity where model-shifting is the **default operating mode**. Any task can be scoped, planned, and handed off to a single agent or a swarm, with each agent running on the model best suited for its work. Quota awareness ensures agents are dispatched to models that have capacity.

---

## Available Models

Sourced from [Antigravity Cockpit](https://github.com/jlcodes99/vscode-antigravity-cockpit) extension.

| Label | Internal ID | Tier | Best For |
|-------|-------------|------|----------|
| Claude Opus 4.5 (Thinking) | `MODEL_PLACEHOLDER_M12` | 1 â€” Architect | Deep reasoning, architecture, subtle debugging |
| Claude Sonnet 4.5 | `MODEL_CLAUDE_4_5_SONNET` | 1 â€” Precision | Code review, plan alignment, security analysis |
| Claude Sonnet 4.5 (Thinking) | `MODEL_CLAUDE_4_5_SONNET_THINKING` | 1 â€” Precision+ | Complex debugging with reasoning traces |
| Gemini 3 Pro (High) | `MODEL_PLACEHOLDER_M7` | 2 â€” Workhorse | Large context, multi-file implementation, refactoring |
| Gemini 3 Pro (Low) | `MODEL_PLACEHOLDER_M8` | 2 â€” Economy | Same capabilities, lower quality/cost tier |
| Gemini 3 Pro Image | `MODEL_PLACEHOLDER_M9` | 2 â€” Visual | Image generation and analysis tasks |
| Gemini 3 Flash | `MODEL_PLACEHOLDER_M18` | 3 â€” Speed | Fast iteration, docs, formatting, simple fixes |
| GPT-OSS 120B (Medium) | `MODEL_OPENAI_GPT_OSS_120B_MEDIUM` | 2 â€” Alternative | Alternative reasoning, diverse perspective |

### Agent-to-Model Mapping

| Agent Role | Primary Model | Fallback | Rationale |
|------------|--------------|----------|-----------|
| **Project Manager** | Claude Sonnet 4.5 (Thinking) | Gemini 3 Pro (High) | Needs reasoning + broad view |
| **Architect** | Claude Opus 4.5 (Thinking) | Claude Sonnet 4.5 (Thinking) | Deepest reasoning for design |
| **Developer** | Gemini 3 Pro (High) | Gemini 3 Pro (Low) | Large context for implementation |
| **Debugger** | Claude Sonnet 4.5 (Thinking) | Gemini 3 Pro (High) | Step-by-step root cause analysis |
| **QA** | Gemini 3 Flash | Gemini 3 Pro (Low) | Fast test execution and review |
| **Code Reviewer** | Claude Sonnet 4.5 | Gemini 3 Pro (High) | Quality and security focus |
| **DevOps** | Gemini 3 Flash | Gemini 3 Pro (Low) | Build/CI commands, fast checks |
| **Explorer** | Gemini 3 Pro (High) | Gemini 3 Flash | Broad codebase scanning |
| **Researcher** | Gemini 3 Pro (High) | GPT-OSS 120B | Web research, doc reading |

---

## Phase Overview

| Phase | Name | Status | Effort |
|-------|------|--------|--------|
| **1A** | Core Merge | âœ… Complete | Foundation â€” minimum viable system |
| **1B** | Enhanced Operations | After 1A | Supervision, autonomy, presets |
| **2A** | NotebookLM Integration | After 1B | Research & persistent knowledge |
| **2B** | Fusebase Integration | After 2A | Artifact storage, project docs, task tracking |
| **3** | Cockpit Quota Awareness | After 2B | Passive quota monitoring |
| **4** | Direct Quota API | Future | Programmatic quota checking |
| **5** | Advanced Capabilities | Future | Qdrant, marketplace, dashboards |

---

## Phase 1A: Core Merge (Now)

Combine `swarm-coordinator` and `model-tag-team` into a single working system. **Goal: the user can run `/swarm` and get agents dispatched on the right models.**

### Deliverables

- Unified `GEMINI.md` â€” identity, default tag-team behaviors, always loaded
- Unified `SKILL.md` â€” full protocol (handoff + swarm + routing)
- Merged manifest schema â€” project state + agents + file claims + phase gates
- 9 agent prompt templates (PM, Architect, Developer, Debugger, QA, Code Reviewer, DevOps, Explorer, Researcher)
- Updated `model_fallback.json` with real model IDs from cockpit
- Core workflows: `/pivot`, `/resume`, `/swarm`, `/health`
- Install script that replaces both existing projects
- `spec.md` template â€” the contract agents work against

### Getting Started Flow

When the unified project is installed, the first-run experience:

```
1. Run install.ps1
   â†’ Creates skill junction
   â†’ Installs workflows
   â†’ Writes GEMINI.md to global location
   â†’ Validates NLM skill is accessible

2. User opens any project and types:
   /swarm Fix the login timeout bug

3. PM agent activates:
   â†’ Reads SKILL.md
   â†’ Analyzes the task
   â†’ Writes spec.md (user approves)
   â†’ Selects agents and models
   â†’ Generates manifest
   â†’ Dispatches Architect

4. Pipeline runs:
   PM â†’ Architect â†’ Developer(s) â†’ QA â†’ Report
```

### Spec Document (`spec.md`)

Before the Architect plans, the PM writes a `spec.md`. This is the **contract** â€” every agent's work is measured against it.

```markdown
# Spec: [Task Title]
> Generated by PM at [timestamp]

## Acceptance Criteria
- [ ] Payment flow supports USD, EUR, GBP
- [ ] All existing tests continue to pass

## Constraints
- Do NOT modify the authentication module
- Must use the existing `PaymentGateway` interface

## Non-Functional Requirements
- API response time < 200ms

## Out of Scope
- Mobile app changes
```

Enforcement: PM writes â†’ user approves â†’ Architect references in plan.md â†’ QA validates acceptance criteria â†’ PM verifies at completion.

---

## Phase 1B: Enhanced Operations

Layer on sophistication for power users. **Goal: full control over supervision level, autonomous operation, and error recovery.**

### Deliverables

- 4 supervision levels (Full â†’ Gate Only â†’ Review End â†’ Autonomous)
- Autonomous mode via `--auto` flag with settings backup/restore
- Cross-model consultation (`/consult`)
- Progress dashboard (`/status`)
- Error recovery protocol
- Git branch strategy with merge protocol
- 6 swarm presets

### Supervision Levels

| Level | Name | Flag | Behavior |
|-------|------|------|----------|
| 1 | **Full Supervision** | (default) | User approves every phase gate, reviews plan, reviews code |
| 2 | **Gate Only** | `--gates` | Agents run autonomously within phases, user approves phase transitions |
| 3 | **Review on Completion** | `--review-end` | Agents run the full pipeline, user reviews only at the end |
| 4 | **Full Autonomous** | `--auto` | No gates, no approvals, agents run to completion |

```
/swarm --gates Refactor the billing module      â† Level 2
/swarm --auto Add multi-currency support         â† Level 4
/swarm Redesign the auth flow                    â† Level 1 (default)
```

### Autonomous Mode (`--auto`)

When the `--auto` flag is present, the coordinator agent:

1. **Saves current settings** to `~/.antigravity-configs/settings_backup.json`
2. **Toggles Antigravity settings** for autonomous operation:

```json
{
  "cascade.autoRunCommands": true,
  "cascade.allowInBackground": true,
  "cascade.autoApproveEdits": true
}
```

3. **Adds auto-mode markers** to the manifest
4. **Restores original settings** when the swarm completes

#### Safety

| Safeguard | How |
|-----------|-----|
| **Settings backup** | Original settings saved before toggle, restored after completion |
| **Scope limits** | Agents still respect file claims and scope boundaries |
| **Manifest audit trail** | All auto-executed commands logged in `## Handoff Notes` |
| **Emergency stop** | User can always cancel via Agent Manager (`Ctrl+E`) |
| **Restore on failure** | `/health` detects orphaned backup and offers restore |

> [!IMPORTANT]
> The exact setting keys need to be verified against the current Antigravity version. The keys above are based on the Cockpit extension's type system (`cascadeCanAutoRunCommands`, `canAllowCascadeInBackground`). The actual VS Code `settings.json` keys may differ slightly.

### Cross-Model Consultation (`/consult`)

When an agent is stuck, instead of a full handoff it can ask a different model for help while **keeping its own context intact**.

#### The Escalation Ladder

| Situation | Action | Cost |
|-----------|--------|------|
| Stuck for 1-2 attempts | Keep trying | Free |
| Stuck for 3+ attempts | **Consult** another model | Low â€” focused question only |
| Context filling up | **Handoff** to fresh session | Medium â€” full manifest |
| Multi-track remaining work | **Swarm** to parallel agents | High â€” full decomposition |

#### How It Works

```
Agent A (stuck):
  1. Writes consult_request.md:
     - What I'm trying to do
     - What I've tried (and why it failed)
     - Specific question + minimal code context
  2. Recommends a model based on problem type
  3. Prompts user: "Dispatch this consult to [model]"

Agent B (consultant):
  1. Reads ONLY consult_request.md
  2. Writes consult_response.md with analysis + approach
  3. Done

Agent A (continues):
  1. Reads consult_response.md
  2. Applies the insight, keeps full context intact
```

| | Consult | Handoff |
|---|---|---|
| **Agent A's context** | Preserved | Lost |
| **Token cost** | Low â€” focused Q&A | High â€” full project state |
| **Time** | ~30 seconds | ~5 minutes |

In autonomous mode, consults are dispatched automatically.

### Progress Dashboard (`/status`)

```
User: /status

ğŸ“Š Swarm Status: Billing Refactor
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
Mode: Gate Only (Level 2)
Phase: 2 of 3 (Implementation)

Agents:
  Î± PM           âœ… Complete  â”‚ Claude Sonnet 4.5
  Îµ Architect    âœ… Complete  â”‚ Claude Opus 4.5
  Î² Developer    ğŸ”„ Active   â”‚ Gemini 3 Pro (High) â”‚ 4 files claimed
  Î³ Developer    ğŸ”„ Active   â”‚ Gemini 3 Pro (High) â”‚ 3 files claimed
  Î´ QA           â³ Pending  â”‚ Gemini 3 Flash

Phase Gates:
  [x] Phase 1 (Planning)
  [ ] Phase 2 (Implementation) â€” 2 agents active
  [ ] Phase 3 (Verification)

Issues: 1 ğŸŸ¡ BUG, 0 ğŸ”´ CONFLICT
Spec: 2/5 acceptance criteria met
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”
```

### Error Recovery Protocol

```
Agent fails
  â†“
1. AUTO-RETRY â€” Same agent, fresh context, include failure context
  â†“ if retry fails
2. CONSULT â€” Ask a different model for guidance
  â†“ if still stuck
3. REPLACE â€” Spawn new agent on fallback model
  â†“ if replacement fails
4. ESCALATE â€” Flag as ğŸ”´ BLOCKED, alert user
```

| Recovery Step | Auto Mode | Supervised Mode |
|---------------|-----------|-----------------|
| Auto-retry | Automatic | Automatic |
| Consult | Automatic | User dispatches |
| Replace | Automatic (PM picks fallback) | User picks replacement |
| Escalate | Pauses for user | Pauses for user |

### Git Branch Strategy

| Phase | Branch | Who |
|-------|--------|-----|
| Setup | `swarm/<task-slug>` | PM creates from `main` |
| Planning | `swarm/<task-slug>` | Architect works on base branch |
| Implementation | `swarm/<task-slug>/<agent-id>` | Each Developer gets a feature branch |
| Verification | `swarm/<task-slug>` | QA works on merged branch |
| Completion | â†’ PR to `main` | PM creates final PR |

Merge conflicts â†’ `## Issues` with `ğŸ”´ CONFLICT`. QA runs on merged base branch. PM creates final PR after QA signs off.

### Swarm Presets

| Preset | Command | Agents | Use Case |
|--------|---------|--------|----------|
| **Standard** | `/swarm <task>` | PM â†’ Architect â†’ Dev(s) â†’ QA | Default |
| **Refactor** | `/swarm --preset=refactor` | Architect â†’ 1 Dev â†’ Code Reviewer | Restructure code |
| **Bugfix** | `/swarm --preset=bugfix` | Debugger â†’ QA | Fast fix |
| **Feature** | `/swarm --preset=feature` | PM â†’ Architect â†’ 2 Devs â†’ Code Reviewer â†’ QA | Full pipeline |
| **Review** | `/swarm --preset=review` | Explorer â†’ Code Reviewer | Read-only analysis |
| **Spike** | `/swarm --preset=spike` | Explorer â†’ Researcher â†’ Architect | Research + prototype |

Combinable: `/swarm --preset=bugfix --auto Fix the login timeout`

---

## Phase 2A: NotebookLM Integration â€” Research & Knowledge Base

Leverage the installed [NotebookLM MCP](file:///C:/Users/ryanh/.gemini/antigravity/skills/nlm-skill/SKILL.md) to give agents a **persistent, queryable knowledge base** with built-in research and content generation.

### Why NotebookLM Before Qdrant

| Capability | Qdrant RAG | NotebookLM |
|------------|-----------|------------|
| **Available today** | Needs deployment | âœ… Already installed |
| **Web research** | Need separate tool | âœ… Built-in (`research start`) |
| **Drive integration** | Need separate tool | âœ… Built-in (`source add --drive`) |
| **Query knowledge** | Vector similarity | âœ… Natural language Q&A |
| **Cross-project** | Needs indexing pipeline | âœ… One notebook per project, queryable |
| **Content generation** | Not applicable | âœ… Reports, slides, summaries |

### Project Notebook Lifecycle

```
Swarm starts
  â†“
PM creates notebook: "Project: Billing Refactor"
  â†“ nlm alias set billing-refactor <notebook-id>
  â†“
Sources added throughout:
  - spec.md, plan.md (text sources)
  - Relevant docs/APIs (URLs)
  - Research results (web/drive discovery)
  â†“
Any agent queries: nlm notebook query <id> "question"
  â†“
On completion â†’ nlm report create <id> --format "Briefing Doc" --confirm
  â†“
Notebook persists for future reference
```

### Agent-to-NLM Capability Mapping

| Agent | NLM Capability | How They Use It |
|-------|---------------|-----------------|
| **Project Manager** | `notebook create`, `note create`, `report create` | Creates project notebook, generates completion reports |
| **Researcher** | `research start`, `source add`, `notebook query` | **Primary NLM user** â€” web/drive research, imports sources |
| **Architect** | `notebook query`, `source describe` | Queries for patterns, asks "has this been solved before?" |
| **Explorer** | `notebook query`, `source add` | Adds codebase docs, queries for architecture patterns |
| **Developer** | `notebook query` | "How should I implement X based on the research?" |
| **Debugger** | `notebook query` | "Has this error pattern been seen before?" |
| **QA** | `notebook query` | "What are the acceptance criteria?" |
| **Code Reviewer** | `notebook query` | "What constraints does the spec define?" |
| **DevOps** | `notebook query` | "What's the deployment strategy from the plan?" |

### Cross-Project Knowledge

```
Project A notebook: "Project: Billing Refactor"
  â””â”€ Sources: spec, plan, research, walkthroughs

PM starting Project B:
  1. nlm notebook list                    # See all project notebooks
  2. nlm notebook query <project-a-id> "relevant patterns for currency handling"
  3. Import findings into Project B's notebook
```

Each completed project leaves behind a **queryable knowledge artifact**.

### Content Generation at Completion

| Product | NLM Command | Use Case |
|---------|------------|----------|
| **Briefing Doc** | `nlm report create <id> --format "Briefing Doc"` | Executive summary |
| **Study Guide** | `nlm report create <id> --format "Study Guide"` | Onboarding doc |
| **Mind Map** | `nlm mindmap create <id>` | Visual overview |
| **Slide Deck** | `nlm slides create <id>` | Stakeholder presentation |
| **Podcast** | `nlm audio create <id> --format deep_dive` | Audio walkthrough |

### NLM Limits & Monitoring

> [!NOTE]
> User is on **Google AI Ultra â†’ NLM Pro plan** (300 sources/notebook).

| Limit | Value (Pro) |
|-------|-------------|
| **Sources per notebook** | 300 |
| **Words per source** | 500,000 |
| **File upload size** | 200 MB |
| **Google Slides per source** | 100 slides |
| **Google Sheets per source** | 100K tokens |

#### Source Monitoring

PM tracks usage in the manifest's `## Notebook` section:

```markdown
## Notebook
| Field | Value |
|-------|-------|
| Notebook ID | `abc123-def456` |
| Alias | `billing-refactor` |
| Plan Limit | 300 sources (Pro) |
| Current Sources | 34 |
| Headroom | 266 remaining |
```

**Rules:**
1. Check count before adding sources
2. If within 5 of limit â†’ alert PM
3. If at limit â†’ PM creates overflow notebook
4. Research agents use `--indices` to selectively import, not bulk-import

#### Notebook Overflow

```
Naming convention:
  Project: <name>                    â† Primary (spec, plan, current sources)
  Project: <name> â€” Research         â† Research overflow
  Project: <name> â€” Archive          â† Completed-phase sources

Aliases:
  billing-refactor
  billing-refactor-research
  billing-refactor-archive
```

#### Per-Source Size Awareness

| Source Type | Risk | Mitigation |
|-------------|------|------------|
| Full codebase dump | Exceeds 500K words | Add specific files only |
| Long conversation logs | Can exceed limits | Summarize first |
| Large PDFs | May hit 200MB | Split or use URL |
| API documentation sites | Fine as URL | NLM extracts content |

### Deliverables

- Researcher agent prompt updated to use NLM as primary research tool
- All agent prompts updated with `notebook query` for knowledge retrieval
- PM creates/manages project notebooks in swarm lifecycle
- Manifest includes `## Notebook` section
- Source limit monitoring in PM behavior
- Cross-project query documented in SKILL.md

### Open Questions
- Should old project notebooks be archived or kept active indefinitely?
- NLM session expires ~20 min â€” how to handle re-auth during long swarms?
- Should we auto-generate a podcast/report at the end of every swarm?

---

## Phase 2B: Fusebase Integration â€” Artifact Storage & Project Documentation

Leverage the [Fusebase MCP](file:///c:/scripts/fusebase-mcp) (46 tools, reverse-engineered API) to give agents a **persistent, structured storage layer** for all project artifacts. While NotebookLM handles research and knowledge queries, Fusebase handles documentation, project management, and deliverable storage.

### Why Fusebase

Right now, swarm artifacts live as local markdown files that are lost when the project moves or branches are cleaned up. Fusebase provides:

| Need | Without Fusebase | With Fusebase |
|------|-----------------|---------------|
| **Spec document** | `spec.md` in project root | Fusebase page â€” versioned, shareable, commentable |
| **Plan/architecture** | `plan.md` disappears with branch | Fusebase page â€” persistent, linked to spec |
| **QA results** | Terminal output lost | Fusebase page â€” timestamped, tagged, searchable |
| **Progress tracking** | Manifest in repo | Fusebase tasks â€” kanban board with status |
| **Test reports** | Scattered files | Fusebase pages â€” organized in workspace folders |
| **Cross-project docs** | Hard to find | Fusebase search + tags |

### Workspace Structure for Agent Swarms

Each swarm project gets a folder tree in a dedicated Fusebase workspace:

```
Workspace: "Agent Swarm Projects"
  â””â”€ Folder: "Billing Refactor" (tagged: #active, #swarm)
     â”œâ”€ ğŸ“„ Spec                    â† PM writes, user approves
     â”œâ”€ ğŸ“„ Architecture Plan       â† Architect writes
     â”œâ”€ ğŸ“ Implementation
     â”‚  â”œâ”€ ğŸ“„ Developer Î² Notes    â† Developer working notes
     â”‚  â””â”€ ğŸ“„ Developer Î³ Notes
     â”œâ”€ ğŸ“ QA & Testing
     â”‚  â”œâ”€ ğŸ“„ Test Results         â† QA writes
     â”‚  â””â”€ ğŸ“„ Code Review Report   â† Code Reviewer writes
     â”œâ”€ ğŸ“„ Swarm Report            â† PM final summary
     â””â”€ ğŸ“‹ Task Board              â† Kanban for all agent tasks
```

### Agent-to-Fusebase Capability Mapping

| Agent | Fusebase Actions | What They Store |
|-------|-----------------|----------------|
| **Project Manager** | `create_page`, `create_task`, `update_page_tags` | Creates project folder, spec page, task board. Tags with `#swarm`, `#active` |
| **Architect** | `create_page`, `update_page_content` | Writes architecture plan, design decisions |
| **Developer** | `create_page`, `update_page_content`, `create_task` | Working notes, implementation decisions, creates subtasks for TODOs |
| **QA** | `create_page`, `create_task` | Test results, bug reports as tasks, coverage data |
| **Code Reviewer** | `create_page` | Review findings, security notes, improvement suggestions |
| **Debugger** | `create_page`, `update_page_content` | Root cause analysis, fix documentation |
| **DevOps** | `create_page` | Build logs, deployment notes, CI results |
| **Researcher** | `create_page` | Research summaries (links back to NLM notebook for deep dives) |
| **Explorer** | `create_page` | Codebase maps, architecture diagrams, pattern catalogs |

### Task Board Integration

The PM creates a Fusebase task board for each swarm. Each agent's work becomes a task:

```
ğŸ“‹ Task Board: "Billing Refactor"

| To Do          | In Progress     | Review          | Done            |
|----------------|-----------------|-----------------|------------------|
| Î³: Payment API |                 |                 | Îµ: Architecture  |
|                | Î²: Gateway impl | Î´: Test suite   | Î±: Spec          |
```

Agents update their task status as they work. The `/status` command reads both the manifest AND the Fusebase task board.

### Fusebase vs NotebookLM â€” Complementary Roles

| Dimension | NotebookLM | Fusebase |
|-----------|-----------|----------|
| **Primary use** | Research & knowledge queries | Document storage & project tracking |
| **Content type** | External sources, Q&A | Agent-written artifacts, specs, reports |
| **Interaction** | Query (ask questions) | CRUD (create, read, update pages) |
| **Persistence** | Notebook per project | Workspace with folders, pages, tasks |
| **Cross-project** | Query old notebooks | Search + tags across all projects |
| **Collaboration** | Read-only for agents | Full read/write with comments |

**Together:** NLM is the **brain** (research, analyze, query). Fusebase is the **filing cabinet** (store, organize, track, share).

### Tagging Convention

All swarm-created pages use consistent tags for searchability:

| Tag | Purpose |
|-----|---------|
| `#swarm` | All pages created by a swarm |
| `#active` / `#completed` / `#archived` | Lifecycle state |
| `#spec` / `#plan` / `#qa` / `#review` | Document type |
| `#agent-Î²` / `#agent-Î³` | Which agent authored it |
| `#project:<name>` | Project grouping |

### Deliverables

- Agent prompts updated to write deliverables to Fusebase
- PM creates project folder structure and task board on swarm start
- All agents write their outputs as Fusebase pages (specs, plans, reports, reviews)
- Task board reflects agent progress in real-time
- Tagging convention for cross-project discovery
- `/status` command reads Fusebase task board
- SKILL.md documents Fusebase MCP tool usage

### Open Questions
- Should every swarm write to Fusebase, or only when `--docs` flag is set?
- How to handle Fusebase auth session expiry during long swarms?
- Should the Fusebase workspace be per-project or one shared workspace with folder isolation?
- Which Fusebase pages should be public (shared as portals) vs private?

---

## Phase 3: Cockpit Quota Awareness (Near-term)

Leverage the [Antigravity Cockpit extension](https://github.com/jlcodes99/vscode-antigravity-cockpit) for quota-aware agent dispatch.

### What We Can Do Now (No Extension Changes)

- **GEMINI.md instruction**: Agents check cockpit status bar before dispatching. If quota < 30%, recommend fallback.
- **Pre-dispatch checklist**: `/swarm` workflow prompts user to confirm quota levels.
- **Manifest quota section**: `## Quota Check` section documents quota state at swarm start.

### Notification System

In supervised modes (Levels 1-3):

- **Agent completion message**: Each agent states *"Phase X complete, ready for review"*
- **Manifest watchfile**: `swarm_status.json` in project root

```json
{
  "task": "Billing Refactor",
  "phase": 2,
  "supervision": "gates",
  "agents_active": 2,
  "agents_complete": 2,
  "agents_pending": 1,
  "last_event": "Î² Developer completed",
  "needs_user_action": false,
  "timestamp": "2026-02-20T22:50:00Z"
}
```

### Deliverables
- Updated `GEMINI.md` with cockpit awareness instructions
- Quota pre-check step in workflows
- `## Quota Check` section in manifest template
- Fallback routing when primary model is exhausted
- `swarm_status.json` for progress tracking

---

## Phase 4: Direct Quota API (Future)

Build `quota-check.ps1` that calls the Antigravity Language Server API directly.

### Architecture

```
quota-check.ps1
  â†’ Finds language_server_windows_x64.exe process
  â†’ Extracts CSRF token + port
  â†’ POST /exa.language_server_pb.LanguageServerService/GetUserStatus
  â†’ Writes quota_snapshot.json

/swarm workflow
  â†’ Reads quota_snapshot.json
  â†’ Auto-selects models based on real-time quota
  â†’ No user input needed
```

### Deliverables
- `scripts/quota-check.ps1` + `scripts/quota-check.sh`
- Workflow reads `quota_snapshot.json` for auto-routing
- Agents can run script mid-session to check before dispatch

### Open Questions
- Periodic background task or on-demand?
- Exclude depleted models or warn?
- TLS â€” LS uses self-signed certs (cockpit uses `rejectUnauthorized: false`)

---

## Phase 5: Advanced Capabilities (Future)

### Qdrant RAG (If Needed)

For offline/airgapped environments or massive-scale indexing:
- Qdrant vector database (self-hosted or cloud)
- Embedding pipeline for manifests, plans, walkthroughs, KIs
- Indexing triggers on project completion

### Cockpit Extension Enhancements

- Cockpit watches `swarm_status.json` and surfaces notifications
- Quota-aware auto-routing without user input
- Visual swarm dashboard in cockpit webview

### Custom Agent Marketplace

- Community-contributed agent roles
- Domain-specific presets (ML, DevOps, frontend, data engineering)
- Agent prompt versioning and testing
